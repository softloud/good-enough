---
format: 
  revealjs:
    theme: solarized
    code-fold: true
    echo: true

title: "ESG Data Governance & Living Analysis Lifescycle"
subtitle: DBT Copenhagen Meetup
date: Wednesday 26 March 2025
bibliography: ../singularities.bib
html-math-method: mathml
author: Charles T. Gray, PhD -- Datapunk
execute:
  freeze: auto
--- 


## Ceci n'est pas un datum

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin-bottom: 2em;">
  <iframe 
    src="https://www.youtube.com/embed/Pyh1Va_mYWI?si=ieVcPdnxgQ83lMGJ&amp;controls=0"
    title="YouTube video player"
    style="position: absolute; top: 0; left: 0; width: 70%; height: 70%; margin: auto; right: 0; bottom: 0;"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>  
</div>

# Tests (*on the presheaf of visualisations*)

## Test: generator $\to$ display

*Test the functor between visualisation generator and slide display.*

Where am I? 

```{r}
getwd()

```

--- 

What am I testing?
```{bash}
cat R/test-mooncake.R

```


Source & Print it
```{r}

source("R/test-mooncake.R")

# Print it 
mooncake_test
```


## *Identity tests*

Can we validate a single datum? 

> I expect there to be a node `ingest` that goes to a node `transform` representing `data engineering` tasks in the `expected` instance of living analysis lifecycle.

```{r}
# source generator
source("R/ButtonCategory.R")

```

## Test edges

```{r}
#| code-fold: false
#| message: true
AnalBeadsEdges <- ButtonEdgeDesignCategory$new()
AnalBeadsEdges$testEdges()
dplyr::sample_n(AnalBeadsEdges$edges, 3)
```

---

```{r}
#| code-fold: false
#| message: true
HairyAnalBeadsEdges <- ButtonEdgeDesignCategory$new(
  preset = "hairy_anal_beads")
HairyAnalBeadsEdges$testEdges()
dplyr::sample_n(HairyAnalBeadsEdges$edges, 3)
```


## Nodes: *Identity test on nodes*

```{r}
#| code-fold: false
#| message: true
AnalBeadsNodes <- ButtonNodeDesignCategory$new()
AnalBeadsNodes$testNodes()
dplyr::sample_n(AnalBeadsNodes$nodes, 3)
```

---

```{r}
#| code-fold: false
#| message: true
HairyAnalBeadsNodes <- ButtonNodeDesignCategory$new(
  preset = "hairy_anal_beads")
HairyAnalBeadsNodes$testNodes()
dplyr::sample_n(HairyAnalBeadsNodes$nodes, 3)

```

---

```{r}
#| code-fold: false
#| message: true
AnalBeads <- ButtonCategory$new(preset = "anal_beads")
AnalBeads$testNodes()
dplyr::sample_n(AnalBeads$nodes, 3)

```

---


```{r}
#| code-fold: false
#| message: true
HairyAnalBeads <- ButtonCategory$new(preset = "hairy_anal_beads")
HairyAnalBeads$testNodes()
dplyr::sample_n(HairyAnalBeads$nodes, 3)

```

## graph

```{r}
to_dot <- function(nodes, edges) {
  # Convert node rows to DOT node declarations
  node_lines <- apply(nodes, 1, function(row) {
    paste0(
      '"', row[["node"]], 
      '" [style=filled, fillcolor="', row[["node_colour"]], 
      '", shape=box];'
    )
  })

  # Convert edge rows to DOT edge declarations
  edge_lines <- apply(edges, 1, function(row) {
    paste0(
      '"', row[["from"]], 
      '" -> "', row[["to"]], 
      '" [style=', row[["line_type"]], '];'
    )
  })

  # Wrap into DOT format
  dot_code <- paste0(
    "digraph {\n  rankdir=LR;\n  node [fontname=Helvetica];\n  ",
    paste(node_lines, collapse = "\n  "), "\n  ",
    paste(edge_lines, collapse = "\n  "), "\n}"
  )

  return(dot_code)
}

```


```{r dot-anal-beads, results="asis"}

# Add example styling columns
AnalBeads$nodes$node_colour <- "lightblue"
AnalBeads$edges$line_type <- "solid"

# Generate DOT code
dot_code <- to_dot(
  nodes = AnalBeads$nodes,
  edges = AnalBeads$edges
)



```

---

```{r}
#| echo: false 
# Render
DiagrammeR::grViz(dot_code)

```

# Earlier tests

*Identity test on edge object.*

Can we validate a single datum? 

> I expect there to be a node `ingest` that goes to a node `transform` representing `data engineering` tasks in the `expected` instance of living analysis lifecycle.

## Test: failed FAIR data entity test

### Expectations

```{r}


# Create the expected datum for testing
# Expecting an edge from "ingest" to "transform" as part of the "data engineering" process

(
  expected_datum <- data.frame(
    from = "ingest",
    to = "transform",
    node_type = "data engineering"
  )
)
```

## Test: failed FAIR data entity test

### Check the Nodes are non-empty

```{r error=TRUE}


# source generator
source("R/ButtonCategory.R")

# generate button graph
AnalBeads <- 
  ButtonCategory$new()

# Get this test to pass on Nodes

# non-empty intersection
nrow(
  AnalBeads$nodes |>
  dplyr::inner_join(expected_datum)
) > 0

```

## Test: failed FAIR data entity test

### Check the column names are as expected 

> Role is a node attribute! 


```{r}


# show expected
expected_datum

# exact columns
all(
  colnames(expected_datum) %in% colnames(AnalBeads$nodes)
)

# show Nodes
head(AnalBeads$nodes, 3)
```

## Test: FAIR data entity test

### Expectations

Expected Nodes.

```{r}


# Create the expected datum for testing
# Expecting an edge from "ingest" to "transform" as part of the "data engineering" process

(
  expected_edge <- data.frame(
    from = "ingest",
    to = "transform"
  )
)

```

Expected nodes.

```{r}
# create expected nodes

(
  expected_nodes <- data.frame(
    name = c("ingest", "transform")
  ) |>
    dplyr::mutate(role = "data engineering")
)

```

## Test: FAIR data entity test

### Check the Nodes are non-empty

```{r error=TRUE}


# source generator
source("R/ButtonCategory.R")

# generate button graph
AnalBeads <- 
  ButtonCategory$new()

# Get this test to pass on Nodes

# non-empty intersection
nrow(
  AnalBeads$nodes |>
  dplyr::inner_join(expected_datum)
) > 0

```

## Test: FAIR data entity test

Check edge column names are as expected 

```{r}


# show expected
expected_edge

# exact columns
all(
  colnames(expected_edge) %in% colnames(AnalBeads$nodes)
)

# show Nodes
head(AnalBeads$nodes, 3)
```

## Test: FAIR data entity test

Check node attributes are as expected

```{r}


# show expected
expected_nodes

# exact columns
all(
  colnames(expected_nodes) %in% colnames(AnalBeads$nodes)
)

# show Nodes
head(AnalBeads$nodes, 3)
```



# References