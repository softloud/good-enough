{
  "hash": "a853c8ed52795c3e25739812af57607a",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  revealjs:\n    theme: solarized\n    code-fold: true\n    echo: true\n\ntitle: \"ESG Data Governance & Living Analysis Lifescycle\"\nsubtitle: DBT Copenhagen Meetup\ndate: Wednesday 26 March 2025\nbibliography: ../singularities.bib\nhtml-math-method: mathml\nauthor: Charles T. Gray, PhD -- Datapunk\nexecute:\n  freeze: auto\n--- \n\n\n\n## Ceci n'est pas un datum\n\n<div style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin-bottom: 2em;\">\n  <iframe \n    src=\"https://www.youtube.com/embed/Pyh1Va_mYWI?si=ieVcPdnxgQ83lMGJ&amp;controls=0\"\n    title=\"YouTube video player\"\n    style=\"position: absolute; top: 0; left: 0; width: 70%; height: 70%; margin: auto; right: 0; bottom: 0;\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n    referrerpolicy=\"strict-origin-when-cross-origin\"\n    allowfullscreen>\n  </iframe>  \n</div>\n\n# Tests (*on the presheaf of visualisations*)\n\n## Test: generator $\\to$ display\n\n*Test the functor between visualisation generator and slide display.*\n\nWhere am I? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/cantabile/Documents/repos/good-enough\"\n```\n\n\n:::\n:::\n\n\n--- \n\nWhat am I testing?\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat R/test-mooncake.R\n\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# test this file loads\n\nmooncake_test = \"hi Mooncake\"\n```\n\n\n:::\n:::\n\n\n\nSource & Print it\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/test-mooncake.R\")\n\n# Print it \nmooncake_test\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi Mooncake\"\n```\n\n\n:::\n:::\n\n\n\n## *Identity tests*\n\nCan we validate a single datum? \n\n> I expect there to be a node `ingest` that goes to a node `transform` representing `data engineering` tasks in the `expected` instance of living analysis lifecycle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# source generator\nsource(\"R/ButtonCategory.R\")\n```\n:::\n\n\n## Test edges\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nAnalBeadsEdges <- ButtonEdgeDesignCategory$new()\nAnalBeadsEdges$testEdges()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if edge names contain required fields:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if edges are non-empty:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEdge test passing status:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::sample_n(AnalBeadsEdges$edges, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  from      to      \n  <chr>     <chr>   \n1 document  analyse \n2 transform validate\n3 source    ingest  \n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nHairyAnalBeadsEdges <- ButtonEdgeDesignCategory$new(\n  preset = \"hairy_anal_beads\")\nHairyAnalBeadsEdges$testEdges()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if edge names contain required fields:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if edges are non-empty:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEdge test passing status:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::sample_n(HairyAnalBeadsEdges$edges, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  from      to        reason                        reason_na project_integrity\n  <chr>     <chr>     <chr>                         <lgl>     <chr>            \n1 interpret transform \"measure\\nmisunderstood\"      FALSE     actioned         \n2 analyse   transform \"needs different\\ndata shape\" FALSE     actioned         \n3 transform validate  \"\"                            TRUE      backlog          \n```\n\n\n:::\n:::\n\n\n\n## Nodes: *Identity test on nodes*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nAnalBeadsNodes <- ButtonNodeDesignCategory$new()\nAnalBeadsNodes$testNodes()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if node names contain required fields:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if nodes are non-empty:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEdge test passing status:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::sample_n(AnalBeadsNodes$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node     \n  <chr>    \n1 question \n2 document \n3 transform\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nHairyAnalBeadsNodes <- ButtonNodeDesignCategory$new(\n  preset = \"hairy_anal_beads\")\nHairyAnalBeadsNodes$testNodes()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if node names contain required fields:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if nodes are non-empty:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEdge test passing status:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::sample_n(HairyAnalBeadsNodes$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node    \n  <chr>   \n1 ingest  \n2 source  \n3 document\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nAnalBeads <- ButtonCategory$new(preset = \"anal_beads\")\nAnalBeads$testNodes()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if node names contain required fields:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if nodes are non-empty:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEdge test passing status:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::sample_n(AnalBeads$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node    \n  <chr>   \n1 source  \n2 question\n3 decision\n```\n\n\n:::\n:::\n\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nHairyAnalBeads <- ButtonCategory$new(preset = \"hairy_anal_beads\")\nHairyAnalBeads$testNodes()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if node names contain required fields:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTest if nodes are non-empty:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nEdge test passing status:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::sample_n(HairyAnalBeads$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node     \n  <chr>    \n1 interpret\n2 decision \n3 ingest   \n```\n\n\n:::\n:::\n\n\n## graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_dot <- function(nodes, edges) {\n  # Convert node rows to DOT node declarations\n  node_lines <- apply(nodes, 1, function(row) {\n    paste0(\n      '\"', row[[\"node\"]], \n      '\" [style=filled, fillcolor=\"', row[[\"node_colour\"]], \n      '\", shape=box];'\n    )\n  })\n\n  # Convert edge rows to DOT edge declarations\n  edge_lines <- apply(edges, 1, function(row) {\n    paste0(\n      '\"', row[[\"from\"]], \n      '\" -> \"', row[[\"to\"]], \n      '\" [style=', row[[\"line_type\"]], '];'\n    )\n  })\n\n  # Wrap into DOT format\n  dot_code <- paste0(\n    \"digraph {\\n  rankdir=LR;\\n  node [fontname=Helvetica];\\n  \",\n    paste(node_lines, collapse = \"\\n  \"), \"\\n  \",\n    paste(edge_lines, collapse = \"\\n  \"), \"\\n}\"\n  )\n\n  return(dot_code)\n}\n```\n:::\n\n\n```{.r .cell-code}\n# Add example styling columns\nAnalBeads$nodes$node_colour <- \"lightblue\"\nAnalBeads$edges$line_type <- \"solid\"\n\n# Generate DOT code\ndot_code <- to_dot(\n  nodes = AnalBeads$nodes,\n  edges = AnalBeads$edges\n)\n```\n\n\n---\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-b1cc6571ccdbda089810\" style=\"width:960px;height:768px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-b1cc6571ccdbda089810\">{\"x\":{\"diagram\":\"digraph {\\n  rankdir=LR;\\n  node [fontname=Helvetica];\\n  \\\"source\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"ingest\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"transform\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"validate\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"document\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"analyse\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"interpret\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"decision\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"question\\\" [style=filled, fillcolor=\\\"lightblue\\\", shape=box];\\n  \\\"question\\\" -> \\\"source\\\" [style=solid];\\n  \\\"source\\\" -> \\\"ingest\\\" [style=solid];\\n  \\\"ingest\\\" -> \\\"transform\\\" [style=solid];\\n  \\\"transform\\\" -> \\\"validate\\\" [style=solid];\\n  \\\"validate\\\" -> \\\"document\\\" [style=solid];\\n  \\\"document\\\" -> \\\"analyse\\\" [style=solid];\\n  \\\"analyse\\\" -> \\\"interpret\\\" [style=solid];\\n  \\\"interpret\\\" -> \\\"decision\\\" [style=solid];\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n# Earlier tests\n\n*Identity test on edge object.*\n\nCan we validate a single datum? \n\n> I expect there to be a node `ingest` that goes to a node `transform` representing `data engineering` tasks in the `expected` instance of living analysis lifecycle.\n\n## Test: failed FAIR data entity test\n\n### Expectations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the expected datum for testing\n# Expecting an edge from \"ingest\" to \"transform\" as part of the \"data engineering\" process\n\n(\n  expected_datum <- data.frame(\n    from = \"ingest\",\n    to = \"transform\",\n    node_type = \"data engineering\"\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    from        to        node_type\n1 ingest transform data engineering\n```\n\n\n:::\n:::\n\n\n## Test: failed FAIR data entity test\n\n### Check the Nodes are non-empty\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# source generator\nsource(\"R/ButtonCategory.R\")\n\n# generate button graph\nAnalBeads <- \n  ButtonCategory$new()\n\n# Get this test to pass on Nodes\n\n# non-empty intersection\nnrow(\n  AnalBeads$nodes |>\n  dplyr::inner_join(expected_datum)\n) > 0\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::inner_join()`:\n! `by` must be supplied when `x` and `y` have no common variables.\nℹ Use `cross_join()` to perform a cross-join.\n```\n\n\n:::\n:::\n\n\n## Test: failed FAIR data entity test\n\n### Check the column names are as expected \n\n> Role is a node attribute! \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# show expected\nexpected_datum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    from        to        node_type\n1 ingest transform data engineering\n```\n\n\n:::\n\n```{.r .cell-code}\n# exact columns\nall(\n  colnames(expected_datum) %in% colnames(AnalBeads$nodes)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# show Nodes\nhead(AnalBeads$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node     \n  <chr>    \n1 source   \n2 ingest   \n3 transform\n```\n\n\n:::\n:::\n\n\n## Test: FAIR data entity test\n\n### Expectations\n\nExpected Nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the expected datum for testing\n# Expecting an edge from \"ingest\" to \"transform\" as part of the \"data engineering\" process\n\n(\n  expected_edge <- data.frame(\n    from = \"ingest\",\n    to = \"transform\"\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    from        to\n1 ingest transform\n```\n\n\n:::\n:::\n\n\nExpected nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create expected nodes\n\n(\n  expected_nodes <- data.frame(\n    name = c(\"ingest\", \"transform\")\n  ) |>\n    dplyr::mutate(role = \"data engineering\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       name             role\n1    ingest data engineering\n2 transform data engineering\n```\n\n\n:::\n:::\n\n\n## Test: FAIR data entity test\n\n### Check the Nodes are non-empty\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# source generator\nsource(\"R/ButtonCategory.R\")\n\n# generate button graph\nAnalBeads <- \n  ButtonCategory$new()\n\n# Get this test to pass on Nodes\n\n# non-empty intersection\nnrow(\n  AnalBeads$nodes |>\n  dplyr::inner_join(expected_datum)\n) > 0\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::inner_join()`:\n! `by` must be supplied when `x` and `y` have no common variables.\nℹ Use `cross_join()` to perform a cross-join.\n```\n\n\n:::\n:::\n\n\n## Test: FAIR data entity test\n\nCheck edge column names are as expected \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# show expected\nexpected_edge\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    from        to\n1 ingest transform\n```\n\n\n:::\n\n```{.r .cell-code}\n# exact columns\nall(\n  colnames(expected_edge) %in% colnames(AnalBeads$nodes)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# show Nodes\nhead(AnalBeads$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node     \n  <chr>    \n1 source   \n2 ingest   \n3 transform\n```\n\n\n:::\n:::\n\n\n## Test: FAIR data entity test\n\nCheck node attributes are as expected\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# show expected\nexpected_nodes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       name             role\n1    ingest data engineering\n2 transform data engineering\n```\n\n\n:::\n\n```{.r .cell-code}\n# exact columns\nall(\n  colnames(expected_nodes) %in% colnames(AnalBeads$nodes)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# show Nodes\nhead(AnalBeads$nodes, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  node     \n  <chr>    \n1 source   \n2 ingest   \n3 transform\n```\n\n\n:::\n:::\n\n\n\n\n# References",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/grViz-binding-1.0.11/grViz.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}