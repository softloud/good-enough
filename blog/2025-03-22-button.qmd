---
title: Button - slides and blog 
code-fold: true
date: "March 14 2025"
author: 
  - name: Dr Charles T. Gray, Datapunk
    orcid: 0000-0002-9978-011X
    affiliations:
      - name: Good Enough Data & Systems Lab
---


```{r echo=TRUE, message=FALSE}

# pkg
library(tidyverse)
library(ggraph)
library(tidygraph)

```

## Hypergraph of the singularity

Digraphs are everywhere, how might we throw them all together to make sense of them?

My instincts are in dimension reduction and in categories. For now, I will start with constructing a hypergraph on three things:

- Epistomological intent
- Functions in scripts
- Scripts that hold functions

See things as they are is useful, modelling how we would like them to be is useful, and finding ways of comparing is useful. But first we need the construction. 



# Structured intelligence system of visualisations for DBT Meetup Copenhagen

I have a blog post, slides, and another blog post where the theme is better.

In only one place is the visualisation displaying as I'd like. 

Let's see how to visualise this. We already have an epistomological intent digraph from a previous post. Now to join the other digraphs to that. 

## Epistemological intent

::: {.panel-tabset}

### edges 

Let $B$ be the graph describing epistomological intent.

```{r}
B_edges <-
  tribble(
    ~from,    ~to,
    "raw",    "edges",
    "edges",  "nodes",
    "raw",    "nodes",
    "edges",  "tidygraph",
    "nodes",  "tidygraph",
    "tidygraph", "ggraph",
    "ggraph",   "display",
    "display",  "deploy"
  )


```

```{r}
# check assumption
colwise_check <- c("from", "to") %in% colnames(B_edges) 

colwise_check

# convert colwise vector to boolean
all(colwise_check) == TRUE


# display edges
B_edges


```

### nodes

Then node metadata often needs to be extracted or inferred. 

A challenge is node joining happens after the graph object is created.

> output key assumption: there is exactly `one row per node` in `B_edges`

```{r}

B_nodes <-
  # extract nodes from edges
  tibble(
    node = c(B_edges$from, B_edges$to)
  ) |>
  # filter to unique nodes
  distinct() |>
  # add node attributes
  mutate(
    # necessary
    node_label = node,

    # contextual
    painpoint = if_else(
      node %in% c("deploy", "tidygraph"),
      TRUE,
      FALSE
    ),
    node_emergence = if_else(
      painpoint == TRUE,
      "miscreant",
      "expected"
    )
  )


```

the antijoin nodes and edges by node should have no rows

```{r}
B_antijoin <-
  {
    tibble(
      node = c(B_edges$from, B_edges$to)
    ) |>
    # filter to unique nodes
    distinct()
  } |> anti_join(B_nodes |> select(node), by = "node")

```

verify assumption 

```{r}
nrow(B_antijoin) == 0

```

display nodes
```{r}
B_nodes
```

### graph

```{r}
B_graph <- 
  B_edges |>
  as_tbl_graph() |>
  activate(nodes) |>
  # add node attributes
  left_join(B_nodes, by = c("name" = "node"))

B_graph

```

### vis

```{r }
#| fig-height: 12 
B_graph |>
  ggraph() +
  geom_edge_link(
    arrow = arrow(
      length  = unit(0.02, "npc"),
      angle = 20
      ),
    alpha = 0.3,
    start_cap = circle(0.03, 'npc'),
    end_cap = circle(0.03, 'npc')
  ) +
  geom_node_point(
    aes(colour = node_emergence)
  ) +
  geom_node_text(
    aes(label = node_label),
    repel = TRUE,
    family = "Courier"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(
      family = "Courier"
      ),
    plot.subtitle = element_text(
      family = "Courier"
      ),    
    plot.caption = element_text(
      family = "Courier"
      ),    
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  ) +
  labs(
    title = "Development Expectation",
    subtitle = "Known problems at tidygraph and deployment"
  ) +
  ggplot2:::manual_scale(
    "colour",
    values = setNames(
      c("#a6611a", "#018571","#dfc27d", "#80cdc1"),
      c("violation", "virtuous", "miscreant", "expected")
    )
  )

```

:::

## Extending to scripts

Let $F$ denote the directed graph of functions. 

::: {.panel-tabset}

### edges

```{r}
F_edges <- tribble(
  ~from, ~to, ~morphism,
  "anal_beads_df", "anal_beads", "df to graph",
  "anal_beads", "anal_beads_vis", "graph to vis",
  "anal_beads_df", "hairy_anal_beads", "df to df",
  "hairy_anal_beads", "hairy_anal_beads_vis", "graph to vis"
)

```

```{r}
#| code-fold: false
F_edges
```

### nodes

```{r}
F_nodes <- 
  tibble(
    name = c(F_edges$from, F_edges$to)
  ) |>
  distinct() |>
  mutate(
    node_label = name,
    node_emergence = "expected",
    node_type = "function"
    )

```

```{r}
#| code-fold: false
F_nodes

```

### graph

```{r}
F_graph <- as_tbl_graph(F_edges) |>
  activate(nodes) |>
  left_join(F_nodes, by = "name")

```

```{r error=TRUE}
#| code-fold: false
F_graph
```

### vis

```{r}
# time to convert this to a list so we can reuse it
button_vis <- list(
  geom_edge_link(
    arrow = arrow(
      length  = unit(0.02, "npc"),
      angle = 20
      ),
    alpha = 0.3,
    start_cap = circle(0.03, 'npc'),
    end_cap = circle(0.03, 'npc')
  ),
  geom_node_point(
    aes(colour = node_emergence)
  ),
  geom_node_text(
    aes(label = node_label),
    repel = TRUE,
    family = "Courier"
  ),
  theme_minimal(),
  theme(
    plot.title = element_text(
      family = "Courier"
      ),
    plot.subtitle = element_text(
      family = "Courier"
      ),    
    plot.caption = element_text(
      family = "Courier"
      ),    
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  ),
  ggplot2:::manual_scale(
    "colour",
    values = setNames(
      c("#a6611a", "#018571","#dfc27d", "#80cdc1"),
      c("violation", "virtuous", "miscreant", "expected")
    )
  )

)


```

```{r}
#| code-fold: false
F_graph |>
  ggraph() +
  button_vis


```

:::

